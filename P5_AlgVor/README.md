El objetivo de esta práctica fue trabajar con algoritmos voraces, los cuales resultan más directos e intuitivos en comparación con otros enfoques como la recursividad o Divide y Vencerás. La idea principal detrás de estos algoritmos es tomar en cada paso la mejor decisión posible en ese momento, sin reconsiderar elecciones anteriores, con la confianza de que para ciertos problemas esta estrategia conduce a la solución óptima de manera rápida y eficiente.

Uno de los problemas abordados fue el del cambio de monedas, cuyo objetivo es dar cambio utilizando la menor cantidad de monedas posible. En este caso, el arreglo de monedas ya se encuentra ordenado de mayor a menor, lo cual es fundamental para que el enfoque voraz funcione correctamente. El algoritmo simplemente calcula cuántas monedas de cada denominación caben en la cantidad restante, las toma todas de una sola vez y actualiza el valor faltante. Este método evita probar combinaciones innecesarias y permite obtener el resultado con muy pocas operaciones, lo que lo hace extremadamente eficiente.

Otro problema implementado fue el de la mochila fraccionaria, donde se busca maximizar el valor total que puede llevar una mochila con capacidad limitada, teniendo la ventaja de que los objetos pueden fraccionarse. En lugar de elegir los objetos por su valor total o por su peso, se calcula la relación entre valor y peso para cada uno, lo que indica qué tan rentable es cargar ese objeto. Posteriormente, los elementos se ordenan de mayor a menor según esta relación y se van agregando a la mochila de forma voraz. Si un objeto ya no cabe completo, se toma únicamente la fracción necesaria para llenar la mochila, momento en el cual el algoritmo termina. Gracias a que los objetos pueden dividirse, esta estrategia siempre garantiza el mejor resultado, a diferencia de la mochila 0/1.

También se analizó el problema de selección de actividades, cuyo objetivo es realizar la mayor cantidad de actividades posibles sin que se empalmen entre sí. Aunque podría parecer lógico elegir la actividad más corta o la que inicia primero, la estrategia correcta consiste en ordenar las actividades por su hora de finalización. Al seleccionar primero la que termina antes, se libera el recurso lo más pronto posible, permitiendo que más actividades puedan acomodarse posteriormente. El algoritmo recorre la lista ordenada y selecciona cada actividad que inicia después de que terminó la anterior.

En cuanto a los resultados, los algoritmos voraces demostraron ser muy rápidos, con tiempos de ejecución del orden de microsegundos. En la mayoría de los casos, la parte más costosa del proceso es el ordenamiento inicial de los datos, por lo que la complejidad total suele estar dominada por este paso. Finalmente, las comparaciones realizadas mostraron que las implementaciones en C son considerablemente más rápidas que las realizadas en Python, aunque este último resulta más sencillo de escribir y entender.
