El objetivo principal de esta práctica fue comparar dos paradigmas de programación muy comunes: la iteración, que se basa en el uso de ciclos como for o while, y la recursividad, donde una función se llama a sí misma. Para hacer esta comparación de forma clara, implementé cuatro algoritmos clásicos utilizando ambos enfoques, con la intención de analizar su desempeño en términos de tiempo de ejecución y consumo de memoria.
El primer algoritmo fue la suma de dígitos, donde el número no se maneja como un tipo entero, sino como una cadena de texto. Esto permite trabajar con números muy grandes sin que ocurra desbordamiento. En la versión iterativa simplemente se recorre la cadena y se van sumando los dígitos, mientras que en la versión recursiva se toma el primer carácter, se suma y se deja que la función se encargue del resto de la cadena.
El segundo algoritmo corresponde a la inversión de una cadena. La lógica consiste en intercambiar el primer y el último carácter e ir cerrando el rango hasta llegar al centro. En la versión recursiva, cada intercambio implica una nueva llamada a la función con un rango más pequeño, lo que provoca que se utilice la pila de llamadas y se consuma más memoria, mientras que la versión iterativa solo mueve los índices sin necesidad de llamadas adicionales.
También se implementó la búsqueda binaria utilizando un arreglo muy grande para que la diferencia de eficiencia fuera más evidente. En ambos casos, tanto iterativo como recursivo, el algoritmo tiene una complejidad logarítmica, lo que lo hace muy rápido. La versión recursiva resulta más elegante y clara al dividir el problema en partes más pequeñas, aunque internamente realiza más llamadas a función.
Por último, se trabajó con la potenciación modular usando el método de exponenciación rápida. En lugar de multiplicar la base tantas veces como indique el exponente, se divide el exponente a la mitad en cada paso, lo que reduce de forma significativa el número de operaciones. En este caso, la versión recursiva ayuda a entender cómo se van almacenando resultados parciales en la pila hasta obtener el resultado final.
Para medir los tiempos de ejecución de forma más precisa, se utilizó la función clock(). Debido a que los algoritmos son muy rápidos, fue necesario ejecutarlos mil veces seguidas dentro de un ciclo para poder obtener mediciones apreciables en milisegundos.
En conclusión, la práctica mostró que, aunque la recursividad suele producir código más limpio y fácil de entender, la iteración generalmente es más eficiente en términos de recursos, ya que no requiere el uso constante de la pila de llamadas. Aun así, en problemas más complejos como la búsqueda binaria o estructuras tipo árbol, la recursividad resulta muy útil y simplifica considerablemente el desarrollo del programa.
